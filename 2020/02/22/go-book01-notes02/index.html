<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>go程序设计语言读书笔记第二章 | ^-^</title><meta name="description" content="go程序设计语言读书笔记第二章"><meta name="keywords" content="笔记,go"><meta name="author" content="StriveLqq"><meta name="copyright" content="StriveLqq"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/myico.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="go程序设计语言读书笔记第二章"><meta name="twitter:description" content="go程序设计语言读书笔记第二章"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg"><meta property="og:type" content="article"><meta property="og:title" content="go程序设计语言读书笔记第二章"><meta property="og:url" content="http://yoursite.com/2020/02/22/go-book01-notes02/"><meta property="og:site_name" content="^-^"><meta property="og:description" content="go程序设计语言读书笔记第二章"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://yoursite.com/2020/02/22/go-book01-notes02/"><link rel="prev" title="go程序设计语言读书笔记第三章" href="http://yoursite.com/2020/02/23/go-book01-notes03/"><link rel="next" title="go程序设计语言读书笔记第一章" href="http://yoursite.com/2020/02/21/go-book01-notes01/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">^-^</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/forum/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photo/"><i class="fa-fw fa fa-photo"></i><span> 图片</span></a></li></ul></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">13</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">11</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">5</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/forum/"><i class="fa-fw fa fa-coffee"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photo/"><i class="fa-fw fa fa-photo"></i><span> 图片</span></a></li></ul></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#第二章、程序结构"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">第二章、程序结构</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1、名称"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">2.1、名称</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2、声明"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">2.2、声明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3、变量"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">2.3、变量</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-3-1、短变量声明"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">2.3.1、短变量声明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-3-2、指针"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">2.3.2、指针</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-3-3、new函数"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">2.3.3、new函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-3-4、变量的生命周期"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">2.3.4、变量的生命周期</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-4-1、多重赋值"><span class="toc_mobile_items-number">1.3.5.</span> <span class="toc_mobile_items-text">2.4.1、多重赋值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-4-2、可赋值性"><span class="toc_mobile_items-number">1.3.6.</span> <span class="toc_mobile_items-text">2.4.2、可赋值性</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-5、类型声明"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">2.5、类型声明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-6、包和文件"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">2.6、包和文件</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-6-1、导入"><span class="toc_mobile_items-number">1.5.1.</span> <span class="toc_mobile_items-text">2.6.1、导入</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-6-2、包初始化"><span class="toc_mobile_items-number">1.5.2.</span> <span class="toc_mobile_items-text">2.6.2、包初始化</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-7、作用域"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">2.7、作用域</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章、程序结构"><span class="toc-number">1.</span> <span class="toc-text">第二章、程序结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、名称"><span class="toc-number">1.1.</span> <span class="toc-text">2.1、名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、声明"><span class="toc-number">1.2.</span> <span class="toc-text">2.2、声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、变量"><span class="toc-number">1.3.</span> <span class="toc-text">2.3、变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1、短变量声明"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.3.1、短变量声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2、指针"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.3.2、指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3、new函数"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3.3、new函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4、变量的生命周期"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.3.4、变量的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1、多重赋值"><span class="toc-number">1.3.5.</span> <span class="toc-text">2.4.1、多重赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2、可赋值性"><span class="toc-number">1.3.6.</span> <span class="toc-text">2.4.2、可赋值性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5、类型声明"><span class="toc-number">1.4.</span> <span class="toc-text">2.5、类型声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6、包和文件"><span class="toc-number">1.5.</span> <span class="toc-text">2.6、包和文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-1、导入"><span class="toc-number">1.5.1.</span> <span class="toc-text">2.6.1、导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-6-2、包初始化"><span class="toc-number">1.5.2.</span> <span class="toc-text">2.6.2、包初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7、作用域"><span class="toc-number">1.6.</span> <span class="toc-text">2.7、作用域</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url((設置頂部圖))"><div id="post-info"><div id="post-title"><div class="posttitle">go程序设计语言读书笔记第二章</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-02-22<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-02-26</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/02/22/go-book01-notes02/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/02/22/go-book01-notes02/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="第二章、程序结构"><a href="#第二章、程序结构" class="headerlink" title="第二章、程序结构"></a>第二章、程序结构</h2><h3 id="2-1、名称"><a href="#2-1、名称" class="headerlink" title="2.1、名称"></a>2.1、名称</h3><ul>
<li>Go中函数、变量、常量、类型、语句标签和包的名称遵循一个简单的规则：名称的开头是一个字母（Unicode中的字符即可）或下划线，后面可以跟任意数量的字符、数字和下划线，并区分大小写。</li>
</ul>
<a id="more"></a>

<ul>
<li>Go有25个像if和switch这样的关键字：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">break</th>
<th align="center">default</th>
<th align="center">func</th>
<th align="center">interface</th>
<th align="center">select</th>
</tr>
</thead>
<tbody><tr>
<td align="center">case</td>
<td align="center">defer</td>
<td align="center">go</td>
<td align="center">map</td>
<td align="center">struct</td>
</tr>
<tr>
<td align="center">chan</td>
<td align="center">alse</td>
<td align="center">goto</td>
<td align="center">package</td>
<td align="center">switch</td>
</tr>
<tr>
<td align="center">const</td>
<td align="center">fallthrough</td>
<td align="center">if</td>
<td align="center">range</td>
<td align="center">type</td>
</tr>
<tr>
<td align="center">continue</td>
<td align="center">for</td>
<td align="center">import</td>
<td align="center">return</td>
<td align="center">var</td>
</tr>
</tbody></table>
<ul>
<li><p>另外，还有三十几个内置的预声明的常量、类型和函数：</p>
<p>常量：true    false    iota    nil</p>
<p>类型：int    int8    int16    int32    int64</p>
<p>​            unit    unit8    unit16    unit32    unit64    unitptr</p>
<p>​            float32    float64    complex128    complex64</p>
<p>​            bool    byte    rune    string    error</p>
<p>函数：make    len    cap    new    append    copy    close    delete</p>
<p>​            complex    real    imag</p>
<p>​            panic    recover</p>
</li>
<li><p>如果一个实体在函数中声明，它只是在函数局部有效，如果声明在函数外，它将对包里面的所有源文件可见，实体第一个字母的大小写决定其可见性是否跨包，如果名称以大写字母的开头，它是导出的，意味着它对包外是可见的和可访问的，可以被自己包之外的其他程序所引用，像fmt包中的Printf，包名总是由小写字母组成。</p>
</li>
</ul>
<h3 id="2-2、声明"><a href="#2-2、声明" class="headerlink" title="2.2、声明"></a>2.2、声明</h3><ul>
<li>有四个主要的声明：<ol>
<li>变量（var）<ol start="2">
<li>常量（const）</li>
<li>类型（type）</li>
<li>函数（func）</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="2-3、变量"><a href="#2-3、变量" class="headerlink" title="2.3、变量"></a>2.3、变量</h3><ul>
<li><p>var声明创建一个具体类型的变量， 然后给它附加一个名字，设置它的初始值。每一个声明有一个通用的形式：<code>var name type = expression</code>。类型和表达式部分可以省略一个，但是不能都省略，若类型省略，它的类型将由初始化表达式决定，如果表达式省略，其初始值对应于类型的零值。Go里面不存在未初始化的变量</p>
</li>
<li><p>可以声明一个变量列表，并选择使用对应的表达式列表对其初始化，忽略类型允许声明多个不同类型的变量，如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="keyword">int</span>						<span class="comment">//int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">"four"</span>		<span class="comment">//bool, float64, string</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>初始值设定可以是字面量值或者任意的表达式，包级别的初始化在main开始之前进行，局部变量初始化和声明一样在函数执行期间进行</p>
</li>
<li><p>变量可以通过调用返回多个值的函数进行初始化：<code>var f, err = os.Open(name)</code>// os.Open返回一个文件和一个错误</p>
</li>
</ul>
<h4 id="2-3-1、短变量声明"><a href="#2-3-1、短变量声明" class="headerlink" title="2.3.1、短变量声明"></a>2.3.1、短变量声明</h4><ul>
<li><p>在函数中，一种称作短变量声明的可选形式可以用来声明和初始化局部变量，它使用<code>name := expression</code>的形式，name的类型由expression的类型决定</p>
</li>
<li><p>因其短小、灵活，故而在局部变量的声明和初始化中主要使用短声明。var声明通常是为那些跟初始化表达式类型不一致的局部变量保留的，或者用于后面才对变量赋值以及变量初始值不重要的情况。</p>
</li>
<li><p>与var声明一样，多个变量可以以短变量声明的方式声明和初始化：<code>i, j = 0, 1</code></p>
</li>
<li><p>与普通的var声明类似，短变量声明也可以用来调用像os.Open那样返回两个或多个值的函数：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...使用 f...</span></span><br><span class="line">f.Close()</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>短变量声明不需要声明所有在左边的变量，如果一些变量在同一词法块中声明，对于那些变量，短声明的行为等同于赋值，如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in, err := os.Open(infile)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">out, err := os.Create(outfile)</span><br><span class="line"><span class="comment">//第一条语句声明了in和err，第二条语句仅声明了out，但向已有的err变量赋了值</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>短变量声明最少声明一个新变量，否则，代码编译将无法通过，如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(infile)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">f, err := os.Create(outfile)		<span class="comment">//编译错误，没有新的变量</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>只有在同一个词法块中已经存在变量的情况下，短变量的声明才和赋值操作一样，外层的声明将被忽略</p>
</li>
</ul>
<h4 id="2-3-2、指针"><a href="#2-3-2、指针" class="headerlink" title="2.3.2、指针"></a>2.3.2、指针</h4><ul>
<li><p>指针的值是一个变量的地址，一个指针指示值所保存的位置，不是所有值都有地址，但是所有变量都有，使用指针，可以在无须知道变量名字的情况下，间接读取或更新变量的值</p>
</li>
<li><p>如果一个变量声明为var x int，表达式&amp;x(x的地址)获取一个指向整型变量的指针，它的类型是整型指针（*int），如果值叫做p，我们说p指向x，或者p包含x的地址，p指向的变量写成 *p,表达式 *p 获取变量的值，一个整型，因为 *p 代表一个变量，所以它也可以出现在赋值操作符左边，用于更新变量的值 。示例代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">1</span></span><br><span class="line">p := &amp;x			<span class="comment">//p 是整型指针， 指向 x</span></span><br><span class="line">fmt.Printfln(*p)<span class="comment">//"1"</span></span><br><span class="line">*p = <span class="number">2</span>			<span class="comment">//等于 x = 2</span></span><br><span class="line">fmt.Prinfln(x)	<span class="comment">//结果"2"</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>每个聚合类型变量的组成（结构体成员或数组中的元素）都是变量，所以也有地址</p>
</li>
<li><p>变量有时候使用一个地址化的值。代表变量的表达式，是唯一可以应用取地址操作符&amp;的表达式。</p>
</li>
<li><p>指针类型的零值是nil，测试<code>p! = nil</code>结果是true说明p指向一个变量，指针是可比较的，两个指针当且仅当指向同一个变量或者两者都是nil的情况下才相等，如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x, y <span class="keyword">int</span></span><br><span class="line">fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="literal">nil</span>)	<span class="comment">//"true false false"</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>函数返回局部变量的地址是非常安全的，如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过调用f产生的局部变量v即使在调用返回后依然存在，指针p依然引用它</span></span><br><span class="line"><span class="keyword">var</span> p = f()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    v := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次调用f都会返回一个不同的值</span></span><br><span class="line">fmt.Println(f() == f())		<span class="comment">//false</span></span><br></pre></td></tr></table></figure></div>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为一个指针包含变量的地址,所以传递一个指针参数给函数，能够让函数更新间接传递的变量值</span></span><br><span class="line"><span class="comment">//这个函数递增一个指针参数所指向的变量，然后返回此变量的新值，于是它可以在表达式中使用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incr</span><span class="params">(p *<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    *p++	<span class="comment">//递增p所指向的值；p自身保持不变</span></span><br><span class="line">    <span class="keyword">return</span> *p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v := <span class="number">1</span></span><br><span class="line">incr(&amp;v)		<span class="comment">//副作用：v现在等于2</span></span><br><span class="line">fmt.Printfln(incr(&amp;v))	<span class="comment">//"3" (v现在是3)</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>每次使用变量的地址或者复制一个指针， 我们就创建了新的别名或者方式来标记同一变 量。 例如， ＊p 是 v 的别名。 指针别名允许我们不用变量的名字来访问变量， 这一点是非常有 用的</p>
</li>
</ul>
<h4 id="2-3-3、new函数"><a href="#2-3-3、new函数" class="headerlink" title="2.3.3、new函数"></a>2.3.3、new函数</h4><ul>
<li><p>另外一种创建变量的方式是使用内置的new函数，表达式new(T) 创建一个未命名的T 类型变量，初始化为T 类型的零值，并返回其地址（地址类型为＊T ）。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := <span class="built_in">new</span>(<span class="keyword">int</span>)		<span class="comment">//*int类型的p，指向未命名的int变量</span></span><br><span class="line">fmt.Println(*p)		<span class="comment">//输出"0"</span></span><br><span class="line">*p = <span class="number">2</span>				<span class="comment">//把未命名的int设置为2</span></span><br><span class="line">fmt.Println(*p)		<span class="comment">//输出"2"</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>使用new 创建的变量和取其地址的普通局部变量没有什么不同， 只是不需要引入（和声<br>明）一个虚拟的名字， 通过new{T) 就可以直接在表达式中使用。</p>
</li>
<li><pre><code class="go"><span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span> *<span class="title">int</span></span> {
    <span class="keyword">return</span> <span class="built_in">new</span>(<span class="keyword">int</span>)
}

<span class="function"><span class="keyword">func</span> <span class="title">newInt</span><span class="params">()</span> *<span class="title">int</span></span> {
    <span class="keyword">var</span> dummy <span class="keyword">int</span>
    <span class="keyword">return</span> &amp;dummy
}
<span class="comment">//上述两个函数有同样的行为</span>
&lt;!--￼<span class="number">9</span>--&gt;</code></pre>
</li>
<li><p>new是一个预声明的函数，不是一个关键字，所以它可以重新定义为另外的其他类型，如：<code>func delta(old, new int) int { return new - old}</code>。自然，在delta函数内，内置的new函数是不可用的。</p>
</li>
</ul>
<h4 id="2-3-4、变量的生命周期"><a href="#2-3-4、变量的生命周期" class="headerlink" title="2.3.4、变量的生命周期"></a>2.3.4、变量的生命周期</h4><ul>
<li><p>生命周期指在程序执行过程中变量存在的时间段。 包级别变量的生命周期是整个程序的执行时间。 相反， 局部变量有一个动态的生命周期：每次执行声明语句时创建一个新的实体， 变量一直生存到它变得不可访问， 这时它占用的存储空间被回收。 函数的参数和返回值也是局部变量， 它们在其闭包函数被调用的时候创建。</p>
</li>
<li><p>那么垃圾回收器如何知道一个变量是否应该被回收？基本思路是每一个包级别的变量，以及每一个当前执行函数的局部变量，可以作为追溯该变量的路径的源头，通过 指针和其他方式的引用可以找到变量。如果变量的路径不存在，那么变量变得不可访问，因此它不会影响任何其他的计算过程。因为变最的生命周期是通过它是否可达来确定的，所以局部变量可在包含它的循环的一次迭代之外继续存活。即使包含它的循环已经返回，它的存在还可能延续。编译器可以选择使用堆或栈上的空间来分配，令人惊奇的是，这个选择不是基于使用var 或 new关键字来声明变量。</p>
</li>
<li><pre><code class="go"><span class="keyword">var</span> global *<span class="keyword">int</span>
<span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> {
    <span class="keyword">var</span> x <span class="keyword">int</span>
    x = <span class="number">1</span>
    global = &amp;x
}
<span class="comment">//这里，x一定使用堆空间,因为它在 f 函数返回以后还可以从 global 变量访问，尽管它被声明为一个局部变量。 这种情况我们说 x 从f中逃逸。</span>
&lt;!--￼<span class="number">10</span>--&gt;


</code></pre>
</li>
</ul>
<h4 id="2-4-1、多重赋值"><a href="#2-4-1、多重赋值" class="headerlink" title="2.4.1、多重赋值"></a>2.4.1、多重赋值</h4><ul>
<li><p>另一种形式的赋值是多重赋值， 它允许几个变量一次性被赋值。 在实际更新变量前， 右 边所有的表达式被推演， 当变量同时出现在赋值符两侧的时候这种形式特别有用，如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换两个变量的值</span></span><br><span class="line">x, y = y, x</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br><span class="line"><span class="comment">//计算两个整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(x, y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> y != <span class="number">0</span> &#123;</span><br><span class="line">        x, y = y, x%y</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



</li>
</ul>
<h4 id="2-4-2、可赋值性"><a href="#2-4-2、可赋值性" class="headerlink" title="2.4.2、可赋值性"></a>2.4.2、可赋值性</h4><ul>
<li><p>赋值语句是显式形式的赋值，但是程序中很多地方的赋值是隐式的：一个函数调用隐式地将参数的值赋给对应参数的变量；一个return语句隐式地将return操作数赋值给结果变 量。复合类型的字面量表达式，如：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>&#125;		<span class="comment">//隐式的给每一个元素赋值</span></span><br><span class="line"><span class="comment">//上述赋值语句等同于下列语句</span></span><br><span class="line">medals[<span class="number">0</span>] = <span class="string">"gold"</span></span><br><span class="line">medals[<span class="number">1</span>] = <span class="string">"silver"</span></span><br><span class="line">medals[<span class="number">2</span>] = <span class="string">"bronze"</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>不管隐式还是显式赋值，如果左边的（变量）和右边的（值）类型相同，它就是合法的。 通俗地说，赋值只有在值对于变量类型是可赋值的时才合法。</p>
</li>
</ul>
<h3 id="2-5、类型声明"><a href="#2-5、类型声明" class="headerlink" title="2.5、类型声明"></a>2.5、类型声明</h3><ul>
<li><p>变量或表达式的类型定义这些值应有的特性， 例如大小（多少位或多少个元素等）、 在内部如何表达、 可以对其进行何种操作以及它们所关联的方法。</p>
</li>
<li><p>type 声明定义一个新的命名类型， 它和某个已有类型使用同样的底层类型。 命名类型提供了一种方式来区分底层类型的不同或者不兼容使用， 这样它们就不会在无意中混用。</p>
<p><code>type name underlying-type</code></p>
</li>
<li><p>类型的声明通常出现在包级别， 这里命名的类型在整个包中可见， 如果名字是导出的（开头使用大写字母）， 其他的包也可以访问它。</p>
</li>
<li><p>注：书上关于类型声明有些不太理解，以后补充</p>
</li>
</ul>
<h3 id="2-6、包和文件"><a href="#2-6、包和文件" class="headerlink" title="2.6、包和文件"></a>2.6、包和文件</h3><ul>
<li>在 Go 语言中包的作用和其他语言中的库或模块作用类似，用于支待模块化、封装、编译隔离和重用。一个包的源代码保存在一个或多个以.go结尾的文件中，它所在目录名的尾部就是包的导入路径， 例如， gopl.io/chl/helloworld 包的文件存储在目录＄GOPATH/src/gopl.io/chl/helloworld 中。</li>
<li>每一个包给他的声明提供独立的命名空间，为了从包外部引用一个函数，我们必须明确修饰标识符来指明所指的是image.Decode或utf16.Decode</li>
<li>包让我们可以通过控制变量在包外面的可见性或导出情况来隐藏信息。 在 Go 里， 通过 一条简单的规则来管理标识符是否对外可见：导出的标识符以大写字母开头。</li>
</ul>
<h4 id="2-6-1、导入"><a href="#2-6-1、导入" class="headerlink" title="2.6.1、导入"></a>2.6.1、导入</h4><h4 id="2-6-2、包初始化"><a href="#2-6-2、包初始化" class="headerlink" title="2.6.2、包初始化"></a>2.6.2、包初始化</h4><h3 id="2-7、作用域"><a href="#2-7、作用域" class="headerlink" title="2.7、作用域"></a>2.7、作用域</h3><ul>
<li><p>声明将名字和程序实体关联起来，如一个函数或一个变量，声明的作用域是指用到声明时所声明名字的源代码段。</p>
</li>
<li><p>声明的作用域是声明在程序文本中出现的区域，它是一个编译时属性，变量的生命周期是变量在程序执行期间能被程序的其他部分所引用的起止时间，它是一个运行时属性</p>
</li>
<li><p>语法快是由大括号围起来的一个语句序列，比如一个循环体或函数体，在语法快内部声明的变量对外部不可见，块把声明包围起来，并且决定了它的可见性</p>
</li>
<li><p>我们可以 把块的概念推广到其他没有显式包含在大括号中的声明代码，将其统称为词法块。包含了全部源代码的词法块，叫做全局块。</p>
</li>
<li><p>当编译器遇到 个名字的引用时，将从最内层的封闭词法块到全局块寻找其声明。如果没有找到，它会报 undeclared name” 错误；如果在内层和外层块都存在这个声明，内层 的将先被找到。这种情况下，内层声明将覆盖外部声明，使它不可访问。</p>
</li>
<li><p>不是所有的词法块都对应于显式大括号包围的语句序列，有一些词法块是隐式的。for循环创建了两个词法块：一个是循环体本身的显式块，以及一个隐式块，它包含了一个闭合结构，其中就有初始化语句中声明的变量，如变量i，隐式块中声明的变量作用域包括条件、后置语句（i++），以及for语句体本身。</p>
</li>
<li><p>像for循环一样，除了本身的主体块之外，if和switch语句还会创建隐式的词法块。</p>
</li>
<li><p>在包级别，声明的顺序和它们的作用域没有关系，所以一个声明可以引用它自己或者跟在它后面的其他声明，使我们可以声明递归或相互递归的类型和函数。如果常量或变量声明 引用它自己，则编译器会报错。</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">StriveLqq</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2020/02/22/go-book01-notes02/">http://yoursite.com/2020/02/22/go-book01-notes02/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处 <a href="http://yoursite.com">^-^</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记    </a><a class="post-meta__tags" href="/tags/go/">go    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.png" alt="支付宝"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/23/go-book01-notes03/"><img class="prev_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>go程序设计语言读书笔记第三章</span></div></a></div><div class="next-post pull_right"><a href="/2020/02/21/go-book01-notes01/"><img class="next_cover lazyload" data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>go程序设计语言读书笔记第一章</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/23/go-book01-notes03/" title="go程序设计语言读书笔记第三章"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-23</div><div class="relatedPosts_title">go程序设计语言读书笔记第三章</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/21/go-book01-notes01/" title="go程序设计语言读书笔记第一章"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-21</div><div class="relatedPosts_title">go程序设计语言读书笔记第一章</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/23/go-book01-notes04/" title="go程序设计语言读书笔记第四章"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Go_book01.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-23</div><div class="relatedPosts_title">go程序设计语言读书笔记第四章</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/20/Unix-book01-notes01/" title="Unix环境高级编程读书笔记"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.2/cover/Unix_book01.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-20</div><div class="relatedPosts_title">Unix环境高级编程读书笔记</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/28/html-book01-note01/" title="HTML5权威指南笔记：基础部分"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.6/cover/html5.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-28</div><div class="relatedPosts_title">HTML5权威指南笔记：基础部分</div></div></a></div><div class="relatedPosts_item"><a href="/2020/02/29/html-book01-note02/" title="HTML5权威指南笔记：进阶部分"><img class="relatedPosts_cover lazyload"data-src="https://cdn.jsdelivr.net/gh/StriveLqq/CDN_for_blog@1.6/cover/html5.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-02-29</div><div class="relatedPosts_title">HTML5权威指南笔记：进阶部分</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'zwoVhxM8Q0P1xgj8a8NzFQ47-gzGzoHsz',
  appKey:'fkasl8llBrI9USIwGU2T9dPU',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By StriveLqq</div><div class="framework-info"><span>欢迎 </span><a href="https://github.com/StriveLqq" target="_blank" rel="noopener"><span>访问</span></a><span class="footer-separator">|</span><span>我的 </span><a href="https://github.com/StriveLqq" target="_blank" rel="noopener"><span>GitHub</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="true" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/click_heart.js"></script></body></html>